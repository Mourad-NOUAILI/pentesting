TOR_IP='127.0.0.1'
TOR_PORT=9150

MAX_RETRIES = 20

cnt = 0

import functools

try:
    import requests
except ImportError:
    print("requests module is not installed")
    print("pip install requests")
    print("or")
    print("pip3 install requests")

try:
    import socks
except ImportError:
    print ("socks module is not installed")
    print ("https://pypi.python.org/pypi/PySocks")
    sys.exit(1)

try:
    import socket
except ImportError:
    print ("socket module is not installed")
    print ("pip install socket")
    sys.exit(1)

try:
    import stem
    from stem import Signal
    from stem.control import Controller, EventType
except ImportError:
    print ("stem module is not installed")
    print ("pip install stem")
    print ("or")
    print ("https://pypi.python.org/pypi/stem")
    sys.exit(1)

from time import sleep
import re
import sys
import os
import platform

import threading
import queue

from optparse import OptionParser

class bcolors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

class brute_force_thread (threading.Thread):
    def __init__(self, thread_id, q):
        super(brute_force_thread, self).__init__()
        self.thread_id = thread_id
        self.q = q
        self.stop_request = threading.Event()
    def run(self):
            while True:
                data = self.q.get()
                brute_force(data[0], data[1])
                self.q.task_done()


    def join(self, timeout=None):
        self.stop_request.set()
        super(brute_force_thread, self).join(timeout)

def brute_force(s, url):
    adapter = requests.adapters.HTTPAdapter(max_retries=MAX_RETRIES)
    s.mount('https://', adapter)
    s.mount('http://', adapter)


    #l1 = l.replace('%EXT%',ext)
    #link = sys.argv[1]+"/"+l1

    sys.stdout.write("\r\x1b[K"+url.__str__())
    sys.stdout.flush()
    #print (url)
    response = s.get(url,  allow_redirects=True, headers={'Connection':'close'})

    a = 0
    if response.history:
        for resp in response.history:
            a = a + 1


    if response.status_code != 404 and  url == response.url:
        #print ("\t" + bcolors.GREEN + url + bcolors.ENDC)
        sys.stdout.write("\r\x1b[K"+ "["+
                            str(response.status_code).__str__()+
                            "] "+
                            "\033[0;32m" + url.__str__() + "\033[0;0m")
        sys.stdout.write("\n")
        sys.stdout.flush()

    global cnt
    cnt += 1
    if cnt % 50 == 0:
        a = 0
        t = threading.Thread(target=renew_connection)
        t.start()
        s = get_tor_session()
        ip = get_ip(s)
        #print ("\tYour IP: " + bcolors.GREEN + str(ip) + bcolors.ENDC)
        sys.stdout.write("\x1b[s\x1b[%d;%df\x1b[K Your IP: %s\x1b[u" % (0, 0, str(ip)))
        sys.stdout.flush()

def renew_connection():
    try:
        with Controller.from_port(port = TOR_PORT) as controller:
            controller.authenticate(password = 'mayar')
            controller.signal(Signal.NEWNYM)
            stream_listener = functools.partial(stream_event, controller)
            controller.add_event_listener(stream_listener, EventType.STREAM)
            #sleep(3)
    except :
        print (bcolors.FAIL + "[Failed]" + bcolors.ENDC)
        print (bcolors.BOLD + "TOR is not enabled in your system. Or, check your Internet connection." + bcolors.ENDC)
        sys.exit(0)


def stream_event(controller, event):
    if event.status == StreamStatus.SUCCEEDED and event.circ_id:
        circ = controller.get_circuit(event.circ_id)

        exit_fingerprint = circ.path[-1][0]
        exit_relay = controller.get_network_status(exit_fingerprint)

        print("Exit relay for our connection to %s" % (event.target))
        print("  address: %s:%i" % (exit_relay.address, exit_relay.or_port))
        print("  fingerprint: %s" % exit_relay.fingerprint)
        print("  nickname: %s" % exit_relay.nickname)
        print("  locale: %s" % controller.get_info("ip-to-country/%s" % exit_relay.address, 'unknown'))
        print("")
    else:
        print (bcolors.BOLD + "TOR is not enabled in your system. Or, check your Internet connection." + bcolors.ENDC)
        sys.exit(0)


def get_tor_session():
    session = requests.session()
    session.proxies = {'http':  'socks5://127.0.0.1:9050',
                       'https': 'socks5://127.0.0.1:9050'
                      }
    return session

def get_ip(session):
    p = re.compile("\d+\.\d+\.\d+\.\d+")
    if session == None:
        with requests.Session() as c:
            try:
                r = c.get('http://httpbin.org/ip')
                m = p.search(str(r.content))
                if m:
                    ip = m.group()
                    return ip
            except:
                print(bcolors.FAIL +  "http://httpbin.org/ip not reachable !" + bcolors.ENDC)

    else:
        m = p.search(str(session.get("http://httpbin.org/ip").content))
        if m:
            ip = m.group()
            return ip


'''def brute_force(s, l,ext):
    adapter = requests.adapters.HTTPAdapter(max_retries=MAX_RETRIES)
    s.mount('https://', adapter)
    s.mount('http://', adapter)

    l1 = l.replace('%EXT%',ext)
    link = sys.argv[1]+"/"+l1

    response = s.get(sys.argv[1]+"/"+l1,  allow_redirects=True)
    a = 0
    if response.history:
        for resp in response.history:
            a = a + 1

        if response.status_code == 200 and link + "/" == response.url:
            print ("\t" + bcolors.GREEN + link + bcolors.ENDC)

    global cnt
    cnt += 1
    if cnt % 10 == 0:
        a = 0
        renew_connection()
        s = get_tor_session()
        ip = get_ip(s)
        print ("\n\tYour IP: " + bcolors.GREEN + str(ip) + bcolors.ENDC)
'''

#Main
if __name__ == "__main__":
    #sys.stdout.write("\x1b[8;{rows};{cols}t".format(rows=32, cols=100))
    system =  platform.system();
    release = platform.release()

    if system == 'Linux':
        os.system("clear")
    elif system == "Windows":
        os.system("cls")

    m = """

██████╗ ██╗██████╗               ██████╗ ██╗   ██╗███████╗████████╗███████╗██████╗
██╔══██╗██║██╔══██╗              ██╔══██╗██║   ██║██╔════╝╚══██╔══╝██╔════╝██╔══██╗
██║  ██║██║██████╔╝    █████╗    ██████╔╝██║   ██║███████╗   ██║   █████╗  ██████╔╝
██║  ██║██║██╔══██╗    ╚════╝    ██╔══██╗██║   ██║╚════██║   ██║   ██╔══╝  ██╔══██╗
██████╔╝██║██║  ██║              ██████╔╝╚██████╔╝███████║   ██║   ███████╗██║  ██║
╚═════╝ ╚═╝╚═╝  ╚═╝              ╚═════╝  ╚═════╝ ╚══════╝   ╚═╝   ╚══════╝╚═╝  ╚═╝

                coded by: blackbird


    """
    parser = OptionParser(usage='usage: %prog [options] arguments')
    parser.add_option("-u", "--url", dest="host")
    parser.add_option("-f", "--file", dest="filename")
    parser.add_option("-t", "--threads", dest="threads")

    (options, args) = parser.parse_args()
    if not options.host:
        parser.error("host no given")
    if not options.filename:
        parser.error('Filename not given')

    print (bcolors.BLUE + m + bcolors.ENDC)
    print("Your system: " + platform.platform())
    print('\n')
    if not options.threads:
        print ("You should specify the number of threads (for example: --threads=10 or -t 10 )")
        print ("If you don't, the program will run very slowly")

        while True:
            ans = input("Continue ?(O/N): ")

            if ans.upper() == 'O':
                break
            if ans.upper() == 'N':
                sys.exit()






    if sys.version_info < (3, 6, 3):
        print(bcolors.FAIL + "You must have Python 3.6 or later." + bcolors.ENDC)
        sys.exit(1)

    try:
        f = open(options.filename, "r")
    except:
        print ("No such file: " + options.filename + '\n')
        sys.exit(1)


    try:
        ip = get_ip(None)
        #print (bcolors.BOLD + "Your real IP: " + bcolors.ENDC +
                                        #bcolors.GREEN + str(ip)+ bcolors.ENDC + '\n')
        sys.stdout.write("\x1b[s\x1b[%d;%df\x1b[K Your IP: %s\x1b[u" % (0, 0, str(ip)))
        sys.stdout.flush()

        print ("[+] Connecting to TOR...", end='')
        t = threading.Thread(target=renew_connection)
        t.start()
        print (bcolors.GREEN + "[Done]" + bcolors.ENDC)

        #sys.stdout.write('\x1b[s');

        session = get_tor_session()
        if session == None:
            print (bcolors.FAIL + "\nError: Can't get TOR session." + bcolors.ENDC)
            sys.exit(1)

        ip = get_ip(session)
        #print (bcolors.BOLD + "\tYour IP: " + bcolors.ENDC +
                            #bcolors.GREEN + str(ip)+ bcolors.ENDC + '\n')
        sys.stdout.write("\x1b[s\x1b[%d;%df\x1b[K Your IP: %s\x1b[u" % (0, 0, str(ip)))
        sys.stdout.flush()


        print ("[+] Dirbustering...")
        folders_list = [folder.strip('\n') for folder in f]
        f.close()

        print("#", len(folders_list), "folders to test.")
        #TODO: mutlithreading with Queue
        if not options.threads:
            nb_threads = 1
        else:
            nb_threads = options.threads
        #print(nb_threads)
        lock = threading.Lock()
        workQueue = queue.Queue()
        threads = []

        for thread_id in range(int(nb_threads)):
            thread = brute_force_thread(thread_id, workQueue)
            thread.daemon = True
            thread.start()
            threads.append(thread)

        #queueLock.acquire()
        lock.acquire()
        for folder in folders_list:

            '''line = f.readline().strip("\n")
            if not line:
                break'''
            '''sys.stdout.write("\r\x1b[K"+line.__str__())
            sys.stdout.flush()'''

            if folder and folder[0] != '#':
                url = options.host + "/" + folder + "/"

                #TODO: mutlithreading with Queue
                #TODO: find files with php, html, js extentions
                workQueue.put([session, url])
                #print(folder)
                #brute_force(session, url)
        #lock.release()
            #brute_force(session, line,'html')
            #brute_force(session, line,'htm')

        #queueLock.release()

        for t in threads:
            t.join()
    except KeyboardInterrupt:
        print (bcolors.FAIL + "\n\nProgram terminated by user !" + bcolors.ENDC)
        sys.exit(1)
